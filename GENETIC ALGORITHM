import random
import math


def fitness(x):
    return x * math.sin(10 * math.pi * x) + 1


def generate_population(size, lower, upper):
    return [random.uniform(lower, upper) for _ in range(size)]

# Tournament selection
def selection(population, k=3):
    selected = random.sample(population, k)
    return max(selected, key=fitness)


def crossover(parent1, parent2):
    alpha = random.random()
    return alpha * parent1 + (1 - alpha) * parent2


def mutate(x, lower, upper, mutation_rate=0.1):
    if random.random() < mutation_rate:
        return random.uniform(lower, upper)
    return x


def genetic_algorithm(pop_size=20, generations=10, lower=-1, upper=2):
    population = generate_population(pop_size, lower, upper)

    for gen in range(generations):
        new_population = []
        for _ in range(pop_size):
            
            p1, p2 = selection(population), selection(population)
            
            child = crossover(p1, p2)
            
            child = mutate(child, lower, upper)
            new_population.append(child)
        population = new_population
 best = max(population, key=fitness)
        print(f"Generation {gen+1}: Best x = {best:.5f}, f(x) = {fitness(best):.5f}")

    return best


best_solution = genetic_algorithm()
print("\nOptimal solution found:")
print(f"x = {best_solution:.5f}, f(x) = {fitness(best_solution):.5f}")
	OUTPUT
Generation 1: Best x = 1.63903, f(x) = 2.54259
Generation 2: Best x = 1.27241, f(x) = 1.96996
Generation 3: Best x = 1.83240, f(x) = 2.55952
Generation 4: Best x = 1.83240, f(x) = 2.55952
Generation 5: Best x = 1.83240, f(x) = 2.55952
Generation 6: Best x = 1.83240, f(x) = 2.55952
Generation 7: Best x = 1.83240, f(x) = 2.55952
Generation 8: Best x = 1.63498, f(x) = 2.45638
Generation 9: Best x = 1.63498, f(x) = 2.45638
Generation 10: Best x = 1.44733, f(x) = 2.44226

Optimal solution found:
x = 1.44733, f(x) = 2.44226

        
