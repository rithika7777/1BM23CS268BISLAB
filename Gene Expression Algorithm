import random

# -----------------------------------
# Knapsack Data
# -----------------------------------
weights = [10, 20, 30, 40, 50]
values  = [60, 100, 120, 240, 150]
capacity = 100

# -----------------------------------
# Parameters
# -----------------------------------
POP_SIZE = 20
GENERATIONS = 10
MUTATION_RATE = 0.1

# -----------------------------------
# Fitness function
# -----------------------------------
def fitness(chrom):
    total_w = 0
    total_v = 0
    for i in range(len(chrom)):
        if chrom[i] == 1:
            total_w += weights[i]
            total_v += values[i]
    return total_v if total_w <= capacity else 0

# -----------------------------------
# Helper Functions
# -----------------------------------
def create_chromosome():
    return [random.randint(0, 1) for _ in range(len(weights))]

def initial_population():
    return [create_chromosome() for _ in range(POP_SIZE)]

def crossover(p1, p2):
    point = random.randint(1, len(p1) - 2)
    return p1[:point] + p2[point:]

def mutate(chrom):
    for i in range(len(chrom)):
        if random.random() < MUTATION_RATE:
            chrom[i] = 1 - chrom[i]
    return chrom

def best_of_population(pop):
    return max(pop, key=lambda x: fitness(x))

# -----------------------------------
# Main Loop
# -----------------------------------
population = initial_population()

for gen in range(GENERATIONS):
    # Select the two best parents
    sorted_pop = sorted(population, key=lambda x: fitness(x), reverse=True)
    p1, p2 = sorted_pop[0], sorted_pop[1]

    # Create new population
    new_pop = []
    for _ in range(POP_SIZE):
        child = crossover(p1, p2)
        mutate(child)
        new_pop.append(child)

    population = new_pop

    # Print generation result
    best = best_of_population(population)
    print(f"Gen {gen} best fitness = {fitness(best)} best chromosome: {best}")
